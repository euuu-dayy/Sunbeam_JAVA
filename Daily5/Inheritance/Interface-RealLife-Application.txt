ğŸ¯ Real-Life Example: Payment Gateway Integration
Imagine youâ€™re building an e-commerce platform, and you have different payment providers: PayPal, Stripe, Razorpay, etc.

You design an interface so all payment providers follow the same contract:

âœ… Step 1: Initial Interface â€” v1.0
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);
}
--------------------------------------------------------------------
Now, your team implements it for PayPal and Stripe:
--------------------------------------------------------------------
public class PayPalGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing $" + amount + " via PayPal");
    }

    @Override
    public boolean refund(double amount) {
        System.out.println("Refunding $" + amount + " via PayPal");
        return true;
    }
}

public class StripeGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing $" + amount + " via Stripe");
    }

    @Override
    public boolean refund(double amount) {
        System.out.println("Refunding $" + amount + " via Stripe");
        return true;
    }
}
âœ… All good. Live in production. Used by hundreds of stores.
--------------------------------------------------------------------
â— Problem: Business wants to add â€œpayment status checkâ€
Product team says: â€œWe need to check if a payment succeeded before shipping the product!â€

So you think â€” letâ€™s add a method to the interface:

âŒ BAD: Breaking Change â€” v2.0 (Donâ€™t do this!)
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);
    String getPaymentStatus(); // â† NEW ABSTRACT METHOD!
}
--------------------------------------------------------------------
â†’ ğŸ’¥ Compile Error Everywhere!

All existing classes (PayPalGateway, StripeGateway, any custom gateways clients wrote) now fail to compile unless they implement getPaymentStatus().

ğŸ›‘ This is a nightmare in real life:

You break every clientâ€™s code.
App Store rejections, server crashes, angry customers.
Even if you fix your own classes, third-party plugins or older versions break.

âœ… Solution 1: Use default Method (Java 8+) â€” Safe Evolution
Instead, add a default implementation:
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);

    // ğŸ‘‡ Safe addition â€” doesn't break existing code
    default String getPaymentStatus() {
        return "UNKNOWN"; // fallback value
    }
}
--------------------------------------------------------------------
â†’ Now, PayPalGateway and StripeGateway still compile and run!

â†’ Later, you can override it where needed:
--------------------------------------------------------------------
public class PayPalGateway implements PaymentGateway {
    // ... other methods ...

    @Override
    public String getPaymentStatus() {
        return queryPayPalAPIForStatus(); // real implementation
    }
}
--------------------------------------------------------------------
âœ… No breaking change â†’ safe deployment â†’ happy customers.

âœ… SCENARIO 1: Adding a default Method â†’ âŒ NO OVERRIDING REQUIRED
Interface:
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);

    // ğŸ‘‡ Default method â€” has implementation!
    default String getPaymentStatus() {
        return "DEFAULT_STATUS";
    }
}
--------------------------------------------------------------------

Implementing Class (NO OVERRIDE!):
--------------------------------------------------------------------
public class PayPalGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Paid via PayPal: $" + amount);
    }

    @Override
    public boolean refund(double amount) {
        System.out.println("Refunded via PayPal: $" + amount);
        return true;
    }

    // âš ï¸ NOTICE: We DID NOT override getPaymentStatus()!
    // â†’ Thatâ€™s 100% OK!
}
--------------------------------------------------------------------
public class Main {
    public static void main(String[] args) {
        PaymentGateway gateway = new PayPalGateway();
        gateway.processPayment(100.0);
        System.out.println("Status: " + gateway.getPaymentStatus()); 
        // Output: "Status: DEFAULT_STATUS"
    }
}
--------------------------------------------------------------------
âœ… It compiles.
âœ… It runs.
âœ… No override needed.


âœ… Solution 2: Create Extended Interface (When You Want Stronger Contract)
Suppose â€œstatus checkingâ€ is critical and should be mandatory for new providers.

You create a new interface:
--------------------------------------------------------------------
public interface AdvancedPaymentGateway extends PaymentGateway {
    String getPaymentStatus(); // now abstract â€” must be implemented
}
--------------------------------------------------------------------
Now:

Old code keeps using PaymentGateway â†’ no break.
New providers (e.g., CryptoGateway) implement AdvancedPaymentGateway â†’ forced to support status check.
--------------------------------------------------------------------
public class CryptoGateway implements AdvancedPaymentGateway {
    @Override
    public void processPayment(double amount) { ... }

    @Override
    public boolean refund(double amount) { ... }

    @Override
    public String getPaymentStatus() {
        return blockchainService.checkTxStatus();
    }
}
--------------------------------------------------------------------
âœ… Clean separation â†’ legacy compatibility + new features.

âœ… SCENARIO 2: Extending Interface â†’ âŒ NO OVERRIDING REQUIRED for OLD classes
Original Interface:
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);
}
--------------------------------------------------------------------
Extended Interface:
--------------------------------------------------------------------
public interface AdvancedPaymentGateway extends PaymentGateway {
    // ğŸ‘‡ NEW abstract method â€” must be implemented by classes that choose this interface
    String getPaymentStatus();
}
--------------------------------------------------------------------
Old Class (Still using original interface â€” NO CHANGE!):
--------------------------------------------------------------------
public class PayPalGateway implements PaymentGateway { // â† Still just PaymentGateway
    @Override
    public void processPayment(double amount) {
        System.out.println("Paid via PayPal: $" + amount);
    }

    @Override
    public boolean refund(double amount) {
        System.out.println("Refunded via PayPal: $" + amount);
        return true;
    }

    // âš ï¸ No getPaymentStatus() here â€” and thatâ€™s FINE!
}
--------------------------------------------------------------------
âœ… Still compiles.
âœ… Still runs.
âœ… No breaking change.

New Class (that chooses the advanced interface):
--------------------------------------------------------------------
public class CryptoGateway implements AdvancedPaymentGateway {
    @Override
    public void processPayment(double amount) { ... }

    @Override
    public boolean refund(double amount) { ... }

    @Override
    public String getPaymentStatus() {  // ğŸ‘ˆ Must override â€” because interface requires it
        return "ON_BLOCKCHAIN";
    }
}
--------------------------------------------------------------------
ğŸŸ¢ Only classes that choose to implement AdvancedPaymentGateway must override getPaymentStatus().
Old classes using PaymentGateway? Zero obligation. 





















