🎯 Real-Life Example: Payment Gateway Integration
Imagine you’re building an e-commerce platform, and you have different payment providers: PayPal, Stripe, Razorpay, etc.

You design an interface so all payment providers follow the same contract:

✅ Step 1: Initial Interface — v1.0
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);
}
--------------------------------------------------------------------
Now, your team implements it for PayPal and Stripe:
--------------------------------------------------------------------
public class PayPalGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing $" + amount + " via PayPal");
    }

    @Override
    public boolean refund(double amount) {
        System.out.println("Refunding $" + amount + " via PayPal");
        return true;
    }
}

public class StripeGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing $" + amount + " via Stripe");
    }

    @Override
    public boolean refund(double amount) {
        System.out.println("Refunding $" + amount + " via Stripe");
        return true;
    }
}
✅ All good. Live in production. Used by hundreds of stores.
--------------------------------------------------------------------
❗ Problem: Business wants to add “payment status check”
Product team says: “We need to check if a payment succeeded before shipping the product!”

So you think — let’s add a method to the interface:

❌ BAD: Breaking Change — v2.0 (Don’t do this!)
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);
    String getPaymentStatus(); // ← NEW ABSTRACT METHOD!
}
--------------------------------------------------------------------
→ 💥 Compile Error Everywhere!

All existing classes (PayPalGateway, StripeGateway, any custom gateways clients wrote) now fail to compile unless they implement getPaymentStatus().

🛑 This is a nightmare in real life:

You break every client’s code.
App Store rejections, server crashes, angry customers.
Even if you fix your own classes, third-party plugins or older versions break.

✅ Solution 1: Use default Method (Java 8+) — Safe Evolution
Instead, add a default implementation:
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);

    // 👇 Safe addition — doesn't break existing code
    default String getPaymentStatus() {
        return "UNKNOWN"; // fallback value
    }
}
--------------------------------------------------------------------
→ Now, PayPalGateway and StripeGateway still compile and run!

→ Later, you can override it where needed:
--------------------------------------------------------------------
public class PayPalGateway implements PaymentGateway {
    // ... other methods ...

    @Override
    public String getPaymentStatus() {
        return queryPayPalAPIForStatus(); // real implementation
    }
}
--------------------------------------------------------------------
✅ No breaking change → safe deployment → happy customers.

✅ SCENARIO 1: Adding a default Method → ❌ NO OVERRIDING REQUIRED
Interface:
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);

    // 👇 Default method — has implementation!
    default String getPaymentStatus() {
        return "DEFAULT_STATUS";
    }
}
--------------------------------------------------------------------

Implementing Class (NO OVERRIDE!):
--------------------------------------------------------------------
public class PayPalGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Paid via PayPal: $" + amount);
    }

    @Override
    public boolean refund(double amount) {
        System.out.println("Refunded via PayPal: $" + amount);
        return true;
    }

    // ⚠️ NOTICE: We DID NOT override getPaymentStatus()!
    // → That’s 100% OK!
}
--------------------------------------------------------------------
public class Main {
    public static void main(String[] args) {
        PaymentGateway gateway = new PayPalGateway();
        gateway.processPayment(100.0);
        System.out.println("Status: " + gateway.getPaymentStatus()); 
        // Output: "Status: DEFAULT_STATUS"
    }
}
--------------------------------------------------------------------
✅ It compiles.
✅ It runs.
✅ No override needed.


✅ Solution 2: Create Extended Interface (When You Want Stronger Contract)
Suppose “status checking” is critical and should be mandatory for new providers.

You create a new interface:
--------------------------------------------------------------------
public interface AdvancedPaymentGateway extends PaymentGateway {
    String getPaymentStatus(); // now abstract — must be implemented
}
--------------------------------------------------------------------
Now:

Old code keeps using PaymentGateway → no break.
New providers (e.g., CryptoGateway) implement AdvancedPaymentGateway → forced to support status check.
--------------------------------------------------------------------
public class CryptoGateway implements AdvancedPaymentGateway {
    @Override
    public void processPayment(double amount) { ... }

    @Override
    public boolean refund(double amount) { ... }

    @Override
    public String getPaymentStatus() {
        return blockchainService.checkTxStatus();
    }
}
--------------------------------------------------------------------
✅ Clean separation → legacy compatibility + new features.

✅ SCENARIO 2: Extending Interface → ❌ NO OVERRIDING REQUIRED for OLD classes
Original Interface:
--------------------------------------------------------------------
public interface PaymentGateway {
    void processPayment(double amount);
    boolean refund(double amount);
}
--------------------------------------------------------------------
Extended Interface:
--------------------------------------------------------------------
public interface AdvancedPaymentGateway extends PaymentGateway {
    // 👇 NEW abstract method — must be implemented by classes that choose this interface
    String getPaymentStatus();
}
--------------------------------------------------------------------
Old Class (Still using original interface — NO CHANGE!):
--------------------------------------------------------------------
public class PayPalGateway implements PaymentGateway { // ← Still just PaymentGateway
    @Override
    public void processPayment(double amount) {
        System.out.println("Paid via PayPal: $" + amount);
    }

    @Override
    public boolean refund(double amount) {
        System.out.println("Refunded via PayPal: $" + amount);
        return true;
    }

    // ⚠️ No getPaymentStatus() here — and that’s FINE!
}
--------------------------------------------------------------------
✅ Still compiles.
✅ Still runs.
✅ No breaking change.

New Class (that chooses the advanced interface):
--------------------------------------------------------------------
public class CryptoGateway implements AdvancedPaymentGateway {
    @Override
    public void processPayment(double amount) { ... }

    @Override
    public boolean refund(double amount) { ... }

    @Override
    public String getPaymentStatus() {  // 👈 Must override — because interface requires it
        return "ON_BLOCKCHAIN";
    }
}
--------------------------------------------------------------------
🟢 Only classes that choose to implement AdvancedPaymentGateway must override getPaymentStatus().
Old classes using PaymentGateway? Zero obligation. 





















