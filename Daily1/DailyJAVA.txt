#1.Course Contents Explaination 

#2.Java History , Versions 
	
JAVA 8 (LTS)
James Gosling - Father of Java Programming language
Pavni Diwanji (Indian who worked in sun microsystems and was in the development team for development of servlet)

Applet - Small java program which runs on a server
Java ME (Micro edition) => Mobile development 
Java SE (Standard edition) => Desktop app development
Java EE (Enterprise edition) => Web Development
 
#3.Java Installation (Directory Structures) 

- Installed JDK version 21
	We saw the folder structure in JDK -
	1. bin => java libraries [ java compiler(javac.exe) + app launcher (java.exe) + debugger ]
	2. include => Header files required for JNI programming (Java Native Interface)
		JNI - (Integration of C/CPP in java)
	3. jre => app launcher (java.exe) + rt.jar(java archives) + jvm.dll (supporting libraries)
	4. src.zip => source codes of java classes like (System class, Scanner class , PrintStream class) THEREFORE (JAVA IS OPEN SOURCE) [1]
	

#4.Creating simple hello-world on notepad(open the terminal , save file ,Compilation and execution) (src to byte code)

	javac Program.java - convert java source code into byte code [.class file]
	java Program -  [.class] file is passed to JVM (bytecode to machine code) 

#5.Explaining Compilation of Java Program with Diagram

	Program.java using(java compiler) => Program.class (using applauncher) => JVM 
	JVM - consists of  4 parts 
		1. class loader - (loads .class files into memory area )
		2. Memory Area - (three type of memory STACK, HEAP , METHOD) 
		3. JIT + Interpreter - JIT (Just in time Compilation) used for caching same statements which are used frequently (like system.out.println)
		4. Garbage Collector - Automatic memory management (Automatic frees the object)

	rt.jar => precompiled classes like (System.class , Integer class , String class etc) 
	--------
	~ If we use System.out.println then it only loads System.class not others , only required classes are used and loaded 
		THEREFORE (JAVA IS DYNAMIC) [2]

#6.JDK VS JRE

Development Tools - Compiler , Debugger , Preprocessor , etc

SDK => Development Tools + Documentation + Runtime Environment + Supporting Libraries
	
JDK => Java Development Tools + Java Documentation + Java Runtime Environment + Java Supporting libraries

JDK => Java Development Tools + Java Documentation + JVM + rt.jar

JDK => Java Development Tools + Java Documentation + JRE [JVM + rt.jar]

ON DEVELOPER MACHINE => JDK + JRE 
ON CLIENT MACHINE => JRE (only)

(JAVA IS PLATFORM DEPENDENT) [3]
------------------------------------------------------------------------------------------------------------

#8.Creating a notepad file with multiple class 

Program.java file =>
class First {
	
	public static void main(String[] args) {
		System.out.println("First");
	}
}

class Second {
	
	public static void main(String[] args) {
		System.out.println("Second");
	}
}

class Third {
	
	public static void main(String[] args) {
		System.out.println("Third");
	}
}

--------------------------------------------------------
Output=>

Microsoft Windows [Version 10.0.26100.6584]
(c) Microsoft Corporation. All rights reserved.

C:\Users\HP>cd C:\Users\HP\OneDrive\Desktop

C:\Users\HP\OneDrive\Desktop>javac Program.java

C:\Users\HP\OneDrive\Desktop>java Program
Error: Could not find or load main class Program
Caused by: java.lang.ClassNotFoundException: Program

C:\Users\HP\OneDrive\Desktop>java First
First

C:\Users\HP\OneDrive\Desktop>java Second
Second

C:\Users\HP\OneDrive\Desktop>java Third
Third
-------------------------------------------------------
CONSIDER classes are not public 
~ We can write multiple clases in single .java file 
~ For each class separate .class file is created (First.class , Second.class , Third.class) 
~ We need to execute every .class file by giving separate java command 
~ We cannot write multiple public classes in single .java file 
~ Name of the public class and filename should be same
~ Multiple public classes are written in multiple .java files

#9.Creating a notepad file with multiple class but one public class (Show error)

#10.Creating the first Hello world Program in STS (Explanation) 

public class Program {
	
	public static void main(String[] args) {
		System.out.println("HelloWorld");
	}
}
----------------------------------------------------------------------

Explanation =>  

class  System {
	static Printstream out ;    //Association
}

System.out.println("HelloWorld");

We have 2 perspectives - 
1. System is a class in java.lang package , out is a static member of the System class.
2. println is a method of the PrintStream class.

#11.Classpath 

#12.Classpath demo notepad (Hello world)
    

#13.Method overload Multiple main (in STS) 

#14.Main case sensitive 

#15.Data types 

	Primitive - GETS SPACE ON STACK SECTION

	Non-Primitive (Reference types) - GETS SPACE ON HEAP SECTION

#17.Area of rectangle (len, br , area ) 

#16.Scanner class (user-name , roll , marks) (Problem) 

	In java.util package

#18.Narrowing and widening 

Widening - no explicit casting required

Narrowing - explicit casting is required


~ (JAVA IS STRONGLY TYPED) [4]
~ we can give same name to method but different arguments this concepts is called as method overloading
~ main method in java can be overloaded 
~ JVM only identifies 
	public static void main (String [] args)


IMPPPPP ******   (demo04) 
Imagine you‚Äôre filling a form

The program is like a person asking you questions one by one:

Program: ‚ÄúRoll number please?‚Äù
You type: 101 and press Enter.

The program takes only 101 (the number).

But the Enter key (\n) you pressed is still sitting in the input box, waiting.

Program: ‚ÄúNow tell me your name.‚Äù
It calls sc.nextLine().

But oh! The input box already has that leftover Enter from the previous step.

So instead of waiting for you to type a name, the program thinks:
‚ÄúOh, I already see a newline! That must be the answer.‚Äù

It gives you an empty name without letting you type.

The Fix (extra sc.nextLine())
Before asking for the actual name, we insert:

sc.nextLine(); // throw away the leftover Enter


This eats up that old Enter key from the buffer.

Now, when the program says ‚ÄúName please?‚Äù, the input box is empty and it really waits for you to type your full name.

‚úÖ Simple Rule to Remember:

nextInt(), nextDouble(), nextLong(), etc. ‚Üí leave the Enter key behind.

nextLine() ‚Üí reads until it finds an Enter key.

So if you mix nextInt() (or similar) with nextLine(), you need that extra nextLine() in between to clear the junk Enter.


You said:
########## You mean to say next line when sees blank space it terminates ?/ ##########

ChatGPT said:
Yes üëç you‚Äôre very close, but let me refine it so it‚Äôs crystal clear:
How nextLine() works
nextLine() reads everything from the current position up to the next newline character (\n).
That newline comes from you pressing the Enter key.
After reading, it removes that newline from the buffer.

Example
int roll = sc.nextInt();   // you type: 101 + Enter
String name = sc.nextLine();


You type 101 and press Enter.
Input buffer looks like this:
[101][\n]
nextInt() reads only 101.
Buffer now:
[\n]
nextLine() sees the \n immediately.
It reads everything up to \n.
But there‚Äôs nothing before \n, so it returns an empty string.
Important distinction üö®
nextLine() terminates at a newline (\n), not at blank space.
Blank spaces ( ) are just characters for nextLine() ‚Äî it will happily include them in the string.
The only thing that makes nextLine() stop is the newline character (Enter).
‚úÖ So to answer your question directly:
No, nextLine() doesn‚Äôt terminate at blank space.
It terminates at the Enter key (newline).


######### DAY 2 ###########

# JAVA is Compiled and Interpreted -
	- Usually, a computer language is either compiled or Interpreted. Java combines both this
	  	approach and makes it a two-stage system.
	- Compiled: Java enables the creation of cross-platform programs by compiling them into an
		intermediate representation called Java Bytecode.
	- Interpreted: Bytecode is then interpreted, which generates machine code that can be directly
		executed by the machine/CPU.  


# JAVA is STRICTLY TYPED -

	- The type of every variable must be known at compile time.
	- You must declare the type of a variable when you define it.
	- The compiler checks type correctness before running the program.

# NAMING CONVENTIONS --


--------------------------------------------------------------------
REFER CLASSWORK FROM NOTEBOOK 
#0.demoo (wrapper classes) (Diagram) ( use of primitive as Objects) 

#1.demo1 (Boxing and unboxing) (Integer) (Converting primitive type to wrapper ( Boxing ) ) 

#2.demo02 (Boxing and unboxing) (Integer) (autoboxing and auto-unboxing) ( i,j,k) ( x,y,z) 

#3.demo03 (Integer to String and vice-versa) (Boxing and unboxing) 

#4.demo04 (boxing , unboxing , autoboxing , auto-unboxing ) (wrapper disadvantages addition example)
   
#5.demo05 (Switch ) (course) 

#6.demo06 (Switch) (do-while) 

(refer notes) (Human)
#7.demo07 ( class and object ) (message pass, Employee class (fields , methods , instance variable , instance method/Concrete) ,  //Concrete Instance method, this reference , anonymous instance) 

#7.demo08 ( class and object ) same as above using this (this refer notes)  

#change salary controlled access 

#7.demo07 ( class and object ) (Employee class getters and setters)

#initialization and assignment 

#8.demo08 (date class) (oop approach writing the class)	
//Step1: Understand requirement and Declare the class 
//Step2: Declare the fields 
//Step3: Creating the instance 
//Step4: access modifiers 
//Step5: calling methods

 

## characteristics of Object 

#9 demo09 (Calender class)  

#9.demo10 (date class) (constructor , paramterless , paramterized , message passing ,default values ) (Calender class)  

#10. demo11 (Person class ) (Constructors) (Constructor chaining) 



    























        