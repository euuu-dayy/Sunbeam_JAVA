//DEEP AND SHALLOW COPY ALSO COVERED


## Object class magic, and the full flow of clone().

ğŸ¯ WHY DO WE CLONE?
To create an independent copy of an object. 

Imagine you have an object, and you want to:

Pass it to a method that might modify it â†’ but you donâ€™t want your original changed.
Keep a backup before making risky changes.
Duplicate data for parallel processing.

ğŸ‘‰ Without cloning, if you just assign:
Date dt2 = dt1; // âŒ This is NOT a copy â€” itâ€™s same object!

Then dt1 and dt2 point to the SAME memory â†’ change one â†’ both change.

âœ… clone() gives you a new object with same data â†’ independent life.

#############(demo02)#############
ğŸ”„ FULL FLOW OF dt1.clone() â€” STEP BY STEP
Letâ€™s trace what happens when you call:
Date dt2 = (Date) dt1.clone();

âœ… STEP 1: You Call dt1.clone()
â†’ JVM looks for clone() in Date class â†’ finds your overridden method.

âœ… STEP 2: Your clone() Method Calls super.clone()

//this(dt1 pe call kiya hamne clone toh this me dt1 jayega aur dt1 ka clone banegaa)***
@Override
protected Object clone() throws CloneNotSupportedException {
    Object temp = super.clone(); // ğŸ‘ˆ This is the magic line
    return temp;
}
â†’ super.clone() means youâ€™re calling Object.clone() â€” the native method inside JVM.

âœ… STEP 3: Object.clone() â€” The Native Magic
The clone() method in java.lang.Object is declared as:
protected native Object clone() throws CloneNotSupportedException;

ğŸ” What does native mean?
â†’ Itâ€™s implemented in C/C++ inside the JVM, not in Java.

ğŸ§  What does Object.clone() actually do?
It does a field-by-field bitwise copy of the objectâ€™s memory â€” a â€œshallow copyâ€.

Think of it as:

â€œAllocate a new block of memory of same size. Copy every bit from original object to new block.â€ 

â¡ï¸ All primitive fields (int, char, boolean, etc.) â†’ copied by value.
â¡ï¸ All reference fields (String, List, other objects) â†’ copied by reference (i.e., memory address).


âœ… STEP 4: JVM Checks Cloneable
Before Object.clone() does anything, it checks:

â— â€œIs this objectâ€™s class implementing Cloneable?â€ 

If NO â†’ throws CloneNotSupportedException.

âœ… Your Date class: implements Cloneable â†’ âœ… PASS.

ğŸ’¡ Cloneable is a marker interface â€” no methods. Itâ€™s just a â€œtagâ€ telling JVM: â€œYes, cloning is allowed for this class.â€ 

âœ… STEP 5: JVM Allocates New Memory & Copies
JVM:

Allocates new memory for a Date object (same size as original).
Copies the bit pattern of dt1 into this new memory.
Returns a reference to this new object.
Since your Date has 3 int fields (each 4 bytes), JVM copies 12 bytes of data (plus object header â€” weâ€™ll get to that).

âœ… STEP 6: Cast and Assign

Date dt2 = (Date) dt1.clone();

â†’ Object.clone() returns Object â†’ you cast to Date â†’ assign to dt2.

Now you have:

dt1 â”€â–º [ Date@1234 ] â†’ { day=1, month=1, year=2020 }
dt2 â”€â–º [ Date@5678 ] â†’ { day=1, month=1, year=2020 } â† same values, different memory!

---------------------------------------------------------------------


#############(demo03)#############
ğŸ”„ STEP-BY-STEP EXECUTION - DEEP COPY

âœ… GOAL
Prove that with deep copy enabled, p1 and p2 are fully independent â€” even when modifying nested objects like Date. 

âœ… STEP 1: Create p1
Person p1 = new Person("Nilesh", 78, 170, new Date(1, 1, 2020));

This does:

Creates a new Date object â†’ letâ€™s call it Date@100
day = 1, month = 1, year = 2020
Creates a new Person object â†’ Person@200
name = "Nilesh" (reference to String pool)
weight = 78, height = 170
birth â†’ Date@100


temp.birth = (Date) this.birth.clone(); // â† DEEP COPY ENABLED!
Letâ€™s walk through every single step â€” with memory diagrams, object references, and JVM-level behavior â€” so you understand exactly what happens and why p2 stays unaffected when you modify p1.

âœ… GOAL
Prove that with deep copy enabled, p1 and p2 are fully independent â€” even when modifying nested objects like Date. 

ğŸ”„ STEP-BY-STEP FLOW â€” WITH DEEP COPY
âœ… STEP 1: Create p1

Person p1 = new Person("Nilesh", 78, 170, new Date(1, 1, 2020));
This does:

Creates a new Date object â†’ letâ€™s call it Date@100
day = 1, month = 1, year = 2020
Creates a new Person object â†’ Person@200
name = "Nilesh" (reference to String pool)
weight = 78, height = 170
birth â†’ Date@100

ğŸ–¼ï¸ MEMORY DIAGRAM â€” After STEP 1
p1 â”€â”€â–º [ Person@200 ]
        â”‚
        â”œâ”€â”€ name   = "Nilesh"  â† String literal (immutable)
        â”œâ”€â”€ weight = 78
        â”œâ”€â”€ height = 170
        â””â”€â”€ birth  â”€â”€â”€â”€â”€â”€â”€â”€â–º [ Date@100 ]
                             â”‚
                             â”œâ”€â”€ day   = 1
                             â”œâ”€â”€ month = 1
                             â””â”€â”€ year  = 2020


âœ… STEP 2: Call p1.clone() â†’ Creates p2

Person p2 = (Person) p1.clone();

â†’ This triggers your overridden clone() in Person:

@Override
protected Object clone() throws CloneNotSupportedException {
    Person temp = (Person) super.clone(); // â† 1. Shallow copy of Person
    temp.birth = (Date) this.birth.clone(); // â† 2. Deep copy of Date
    return temp;
}

Letâ€™s break this into two substeps.

â¤ SUBSTEP 2.1: super.clone() â€” Shallow Copy of Person
Person temp = (Person) super.clone();

â†’ JVM creates a new Person object â†’ Person@300
â†’ Copies all field values from p1 (Person@200) to temp (Person@300)

Result:

name â†’ same reference to "Nilesh" (safe â€” immutable)
weight â†’ 78 (copied value)
height â†’ 170 (copied value)
birth â†’ same reference â†’ still points to Date@100 â— (for now â€” weâ€™ll fix this next)

ğŸ–¼ï¸ MEMORY DIAGRAM â€” After super.clone()
p1 â”€â”€â–º [ Person@200 ]
        â”‚
        â””â”€â”€ birth â”€â”€â”€â”€â”€â”€â”€â”
                         â–¼
                   [ Date@100 ] â† Still shared!
                         â”‚

temp â”€â–º [ Person@300 ]   â† New Person object
        â”‚
        â””â”€â”€ birth â”€â”€â”€â”€â”€â”€â”€â”˜  â† Still pointing to same Date@100


â¤ SUBSTEP 2.2: temp.birth = (Date) this.birth.clone(); â€” Deep Copy!

temp.birth = (Date) this.birth.clone();

â†’ this.birth is Date@100 â†’ you call clone() on it.

â†’ Inside Date.clone():
@Override
protected Object clone() throws CloneNotSupportedException {
    Object temp = super.clone(); // shallow copy â€” but Date has only primitives â†’ SAFE!
    return temp;
}

â†’ JVM creates a new Date object â†’ Date@400
â†’ Copies field values: day=1, month=1, year=2020 â†’ independent copy!

â†’ Now assign this new Date@400 to temp.birth

ğŸ–¼ï¸ MEMORY DIAGRAM â€” After Deep Copy

p1 â”€â”€â–º [ Person@200 ]
        â”‚
        â””â”€â”€ birth â”€â”€â”€â”€â”€â”€â”€â–º [ Date@100 ] â†’ {1,1,2020}

temp â”€â–º [ Person@300 ]
        â”‚
        â””â”€â”€ birth â”€â”€â”€â”€â”€â”€â”€â–º [ Date@400 ] â†’ {1,1,2020} â† NEW, INDEPENDENT OBJECT!

âœ… p1.birth and p2.birth now point to different Date objects.

â†’ Assign temp to p2:

Person p2 = (Person) p1.clone(); // p2 now points to Person@300

âœ… STEP 3: Modify p1â€™s Birth Date
p1.getBirth().setDay(1);
p1.getBirth().setMonth(2);
p1.getBirth().setYear(2024);

â†’ p1.getBirth() returns Date@100
â†’ You modify Date@100 â†’ now it becomes { day=1, month=2, year=2024 }

ğŸ–¼ï¸ MEMORY DIAGRAM â€” After Modification

p1 â”€â”€â–º [ Person@200 ]
        â”‚
        â””â”€â”€ birth â”€â”€â”€â”€â”€â”€â”€â–º [ Date@100 ] â†’ {1, 2, 2024} â† MODIFIED

p2 â”€â”€â–º [ Person@300 ]
        â”‚
        â””â”€â”€ birth â”€â”€â”€â”€â”€â”€â”€â–º [ Date@400 ] â†’ {1, 1, 2020} â† UNCHANGED!

âœ… p2â€™s birth date is untouched â€” because it points to a separate Date object.

âœ… STEP 4: Print p1 and p2

System.out.println(p1.toString());
System.out.println(p2.toString());

Output:
Person [name=Nilesh, weight=78, height=170, birth=Date [day=1, month=2, year=2024]]
Person [name=Nilesh, weight=78, height=170, birth=Date [day=1, month=1, year=2020]]

---------------------------------------------------------------------

#############(demo04)#############

We removed Cloneable and clone(), and instead did:

Date dt2 = dt1; // â† This is NOT cloning â€” itâ€™s reference assignment!

Weâ€™ll go step by step, with memory diagrams, JVM internals, and clear explanations â€” so you understand exactly whatâ€™s happening and why this is not a copy at all.

â— IMPORTANT: This is NOT cloning. This is reference copying.
You wrote a comment:
Date dt2 = dt1; // shallow copy of references

â¡ï¸ Thatâ€™s misleading.

âœ… This is not even a shallow copy of the object â€” itâ€™s a copy of the REFERENCE. 

Thereâ€™s only one object â€” and two variables pointing to it.

ğŸ”„ STEP-BY-STEP EXECUTION

âœ… STEP 1: Create dt1

Date dt1 = new Date(1, 1, 2020);

â†’ JVM creates a new Date object in heap memory â†’ letâ€™s call it Date@100
â†’ dt1 is a reference variable that holds the memory address of Date@100

Object state:

day = 1
month = 1
year = 2020

ğŸ–¼ï¸ MEMORY DIAGRAM â€” After STEP 1

dt1 â”€â”€â”€â”€â”€â”€â”€â–º [ Date@100 ]
              â”‚
              â”œâ”€â”€ day   = 1
              â”œâ”€â”€ month = 1
              â””â”€â”€ year  = 2020

âœ… One object. One reference (dt1) pointing to it.

âœ… STEP 2: Assign dt1 to dt2

Date dt2 = dt1;

â†’ This does NOT create a new object.
â†’ This copies the value of the reference â€” i.e., the memory address â€” from dt1 to dt2.

Now both dt1 and dt2 point to the same object â†’ Date@100

ğŸ–¼ï¸ MEMORY DIAGRAM â€” After STEP 2

dt1 â”€â”€â”€â”
       	â”‚
       	â–¼
    [ Date@100 ] â† Both dt1 and dt2 point here!
       â”‚
       â”œâ”€â”€ day   = 1
       â”œâ”€â”€ month = 1
       â””â”€â”€ year  = 2020
       	â–²
       	â”‚
dt2 â”€â”€â”€â”˜

ğŸš¨ There is only one object in memory.
ğŸš¨ dt1 and dt2 are two names for the same thing. 

âœ… STEP 3: Print dt1 and dt2

System.out.println(dt1.toString());
System.out.println(dt2.toString());

â†’ Both call toString() on the same object â†’ Date@100
â†’ So both print:

Date [day=1, month=1, year=2020]
Date [day=1, month=1, year=2020]

âœ… Output is same â€” but not because of copying â€” because theyâ€™re the same object.

ğŸ”„ Letâ€™s Prove Theyâ€™re the Same Object

Add this after printing:

dt2.setDay(15);
dt2.setMonth(8);
dt2.setYear(2024);

System.out.println("After modifying dt2:");
System.out.println("dt1: " + dt1);
System.out.println("dt2: " + dt2);

ğŸ’¥ Output:

After modifying dt2:
dt1: Date [day=15, month=8, year=2024]
dt2: Date [day=15, month=8, year=2024]

ğŸ˜± Changing dt2 changed dt1!

ğŸ–¼ï¸ MEMORY DIAGRAM â€” After Modification

dt1 â”€â”€â”€â”
       	â”‚
       	â–¼
    [ Date@100 ] â† day=15, month=8, year=2024
      	â–²
       	â”‚
dt2 â”€â”€â”€â”˜

âœ… Confirmed â€” only one object. Two references. One change â†’ both see it.