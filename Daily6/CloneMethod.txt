//DEEP AND SHALLOW COPY ALSO COVERED


## Object class magic, and the full flow of clone().

🎯 WHY DO WE CLONE?
To create an independent copy of an object. 

Imagine you have an object, and you want to:

Pass it to a method that might modify it → but you don’t want your original changed.
Keep a backup before making risky changes.
Duplicate data for parallel processing.

👉 Without cloning, if you just assign:
Date dt2 = dt1; // ❌ This is NOT a copy — it’s same object!

Then dt1 and dt2 point to the SAME memory → change one → both change.

✅ clone() gives you a new object with same data → independent life.

#############(demo02)#############
🔄 FULL FLOW OF dt1.clone() — STEP BY STEP
Let’s trace what happens when you call:
Date dt2 = (Date) dt1.clone();

✅ STEP 1: You Call dt1.clone()
→ JVM looks for clone() in Date class → finds your overridden method.

✅ STEP 2: Your clone() Method Calls super.clone()

//this(dt1 pe call kiya hamne clone toh this me dt1 jayega aur dt1 ka clone banegaa)***
@Override
protected Object clone() throws CloneNotSupportedException {
    Object temp = super.clone(); // 👈 This is the magic line
    return temp;
}
→ super.clone() means you’re calling Object.clone() — the native method inside JVM.

✅ STEP 3: Object.clone() — The Native Magic
The clone() method in java.lang.Object is declared as:
protected native Object clone() throws CloneNotSupportedException;

🔍 What does native mean?
→ It’s implemented in C/C++ inside the JVM, not in Java.

🧠 What does Object.clone() actually do?
It does a field-by-field bitwise copy of the object’s memory — a “shallow copy”.

Think of it as:

“Allocate a new block of memory of same size. Copy every bit from original object to new block.” 

➡️ All primitive fields (int, char, boolean, etc.) → copied by value.
➡️ All reference fields (String, List, other objects) → copied by reference (i.e., memory address).


✅ STEP 4: JVM Checks Cloneable
Before Object.clone() does anything, it checks:

❗ “Is this object’s class implementing Cloneable?” 

If NO → throws CloneNotSupportedException.

✅ Your Date class: implements Cloneable → ✅ PASS.

💡 Cloneable is a marker interface — no methods. It’s just a “tag” telling JVM: “Yes, cloning is allowed for this class.” 

✅ STEP 5: JVM Allocates New Memory & Copies
JVM:

Allocates new memory for a Date object (same size as original).
Copies the bit pattern of dt1 into this new memory.
Returns a reference to this new object.
Since your Date has 3 int fields (each 4 bytes), JVM copies 12 bytes of data (plus object header — we’ll get to that).

✅ STEP 6: Cast and Assign

Date dt2 = (Date) dt1.clone();

→ Object.clone() returns Object → you cast to Date → assign to dt2.

Now you have:

dt1 ─► [ Date@1234 ] → { day=1, month=1, year=2020 }
dt2 ─► [ Date@5678 ] → { day=1, month=1, year=2020 } ← same values, different memory!

---------------------------------------------------------------------


#############(demo03)#############
🔄 STEP-BY-STEP EXECUTION - DEEP COPY

✅ GOAL
Prove that with deep copy enabled, p1 and p2 are fully independent — even when modifying nested objects like Date. 

✅ STEP 1: Create p1
Person p1 = new Person("Nilesh", 78, 170, new Date(1, 1, 2020));

This does:

Creates a new Date object → let’s call it Date@100
day = 1, month = 1, year = 2020
Creates a new Person object → Person@200
name = "Nilesh" (reference to String pool)
weight = 78, height = 170
birth → Date@100


temp.birth = (Date) this.birth.clone(); // ← DEEP COPY ENABLED!
Let’s walk through every single step — with memory diagrams, object references, and JVM-level behavior — so you understand exactly what happens and why p2 stays unaffected when you modify p1.

✅ GOAL
Prove that with deep copy enabled, p1 and p2 are fully independent — even when modifying nested objects like Date. 

🔄 STEP-BY-STEP FLOW — WITH DEEP COPY
✅ STEP 1: Create p1

Person p1 = new Person("Nilesh", 78, 170, new Date(1, 1, 2020));
This does:

Creates a new Date object → let’s call it Date@100
day = 1, month = 1, year = 2020
Creates a new Person object → Person@200
name = "Nilesh" (reference to String pool)
weight = 78, height = 170
birth → Date@100

🖼️ MEMORY DIAGRAM — After STEP 1
p1 ──► [ Person@200 ]
        │
        ├── name   = "Nilesh"  ← String literal (immutable)
        ├── weight = 78
        ├── height = 170
        └── birth  ────────► [ Date@100 ]
                             │
                             ├── day   = 1
                             ├── month = 1
                             └── year  = 2020


✅ STEP 2: Call p1.clone() → Creates p2

Person p2 = (Person) p1.clone();

→ This triggers your overridden clone() in Person:

@Override
protected Object clone() throws CloneNotSupportedException {
    Person temp = (Person) super.clone(); // ← 1. Shallow copy of Person
    temp.birth = (Date) this.birth.clone(); // ← 2. Deep copy of Date
    return temp;
}

Let’s break this into two substeps.

➤ SUBSTEP 2.1: super.clone() — Shallow Copy of Person
Person temp = (Person) super.clone();

→ JVM creates a new Person object → Person@300
→ Copies all field values from p1 (Person@200) to temp (Person@300)

Result:

name → same reference to "Nilesh" (safe — immutable)
weight → 78 (copied value)
height → 170 (copied value)
birth → same reference → still points to Date@100 ❗ (for now — we’ll fix this next)

🖼️ MEMORY DIAGRAM — After super.clone()
p1 ──► [ Person@200 ]
        │
        └── birth ───────┐
                         ▼
                   [ Date@100 ] ← Still shared!
                         │

temp ─► [ Person@300 ]   ← New Person object
        │
        └── birth ───────┘  ← Still pointing to same Date@100


➤ SUBSTEP 2.2: temp.birth = (Date) this.birth.clone(); — Deep Copy!

temp.birth = (Date) this.birth.clone();

→ this.birth is Date@100 → you call clone() on it.

→ Inside Date.clone():
@Override
protected Object clone() throws CloneNotSupportedException {
    Object temp = super.clone(); // shallow copy — but Date has only primitives → SAFE!
    return temp;
}

→ JVM creates a new Date object → Date@400
→ Copies field values: day=1, month=1, year=2020 → independent copy!

→ Now assign this new Date@400 to temp.birth

🖼️ MEMORY DIAGRAM — After Deep Copy

p1 ──► [ Person@200 ]
        │
        └── birth ───────► [ Date@100 ] → {1,1,2020}

temp ─► [ Person@300 ]
        │
        └── birth ───────► [ Date@400 ] → {1,1,2020} ← NEW, INDEPENDENT OBJECT!

✅ p1.birth and p2.birth now point to different Date objects.

→ Assign temp to p2:

Person p2 = (Person) p1.clone(); // p2 now points to Person@300

✅ STEP 3: Modify p1’s Birth Date
p1.getBirth().setDay(1);
p1.getBirth().setMonth(2);
p1.getBirth().setYear(2024);

→ p1.getBirth() returns Date@100
→ You modify Date@100 → now it becomes { day=1, month=2, year=2024 }

🖼️ MEMORY DIAGRAM — After Modification

p1 ──► [ Person@200 ]
        │
        └── birth ───────► [ Date@100 ] → {1, 2, 2024} ← MODIFIED

p2 ──► [ Person@300 ]
        │
        └── birth ───────► [ Date@400 ] → {1, 1, 2020} ← UNCHANGED!

✅ p2’s birth date is untouched — because it points to a separate Date object.

✅ STEP 4: Print p1 and p2

System.out.println(p1.toString());
System.out.println(p2.toString());

Output:
Person [name=Nilesh, weight=78, height=170, birth=Date [day=1, month=2, year=2024]]
Person [name=Nilesh, weight=78, height=170, birth=Date [day=1, month=1, year=2020]]

---------------------------------------------------------------------

#############(demo04)#############

We removed Cloneable and clone(), and instead did:

Date dt2 = dt1; // ← This is NOT cloning — it’s reference assignment!

We’ll go step by step, with memory diagrams, JVM internals, and clear explanations — so you understand exactly what’s happening and why this is not a copy at all.

❗ IMPORTANT: This is NOT cloning. This is reference copying.
You wrote a comment:
Date dt2 = dt1; // shallow copy of references

➡️ That’s misleading.

✅ This is not even a shallow copy of the object — it’s a copy of the REFERENCE. 

There’s only one object — and two variables pointing to it.

🔄 STEP-BY-STEP EXECUTION

✅ STEP 1: Create dt1

Date dt1 = new Date(1, 1, 2020);

→ JVM creates a new Date object in heap memory → let’s call it Date@100
→ dt1 is a reference variable that holds the memory address of Date@100

Object state:

day = 1
month = 1
year = 2020

🖼️ MEMORY DIAGRAM — After STEP 1

dt1 ───────► [ Date@100 ]
              │
              ├── day   = 1
              ├── month = 1
              └── year  = 2020

✅ One object. One reference (dt1) pointing to it.

✅ STEP 2: Assign dt1 to dt2

Date dt2 = dt1;

→ This does NOT create a new object.
→ This copies the value of the reference — i.e., the memory address — from dt1 to dt2.

Now both dt1 and dt2 point to the same object → Date@100

🖼️ MEMORY DIAGRAM — After STEP 2

dt1 ───┐
       	│
       	▼
    [ Date@100 ] ← Both dt1 and dt2 point here!
       │
       ├── day   = 1
       ├── month = 1
       └── year  = 2020
       	▲
       	│
dt2 ───┘

🚨 There is only one object in memory.
🚨 dt1 and dt2 are two names for the same thing. 

✅ STEP 3: Print dt1 and dt2

System.out.println(dt1.toString());
System.out.println(dt2.toString());

→ Both call toString() on the same object → Date@100
→ So both print:

Date [day=1, month=1, year=2020]
Date [day=1, month=1, year=2020]

✅ Output is same — but not because of copying — because they’re the same object.

🔄 Let’s Prove They’re the Same Object

Add this after printing:

dt2.setDay(15);
dt2.setMonth(8);
dt2.setYear(2024);

System.out.println("After modifying dt2:");
System.out.println("dt1: " + dt1);
System.out.println("dt2: " + dt2);

💥 Output:

After modifying dt2:
dt1: Date [day=15, month=8, year=2024]
dt2: Date [day=15, month=8, year=2024]

😱 Changing dt2 changed dt1!

🖼️ MEMORY DIAGRAM — After Modification

dt1 ───┐
       	│
       	▼
    [ Date@100 ] ← day=15, month=8, year=2024
      	▲
       	│
dt2 ───┘

✅ Confirmed — only one object. Two references. One change → both see it.