## (demo04) -- Generic Programming Using java.lang.Object
	//Generic class till Java 1.4

(main1) -->

Box b5 = new Box(); 
b5.setObj("123");  // String Object
Integer r5 = (Integer) b5.getObj(); // type-checking at run-time -- ClassCastException , 
//Here we are converting String to Integer which is not possible
System.out.println("r5 : "+r5);

- Type checking is done at run time this is a problem
- At compile time we are not able to know the problem 

-----------------------------------------------------------

(main2) -->

List list = new ArrayList();
list.add(10); 
list.add(20); 
list.add(30); 
list.add(40); 
list.add("50"); //type-checking is done at run-time
		
for(Object obj : list) {
	Integer ele = (Integer) obj; //ClassCastException for "50"
	System.out.println(ele);
}
===========================================================

## (demo05) -- Generic Programming Using Generics

	//Generic class since Java 5.0

(main1) -->

Box<Integer> b1 = new Box<Integer>(); //Here we are already specifying that only Integer type objects are allowed
b1.setObj(new Integer(10));
Integer r1 = b1.getObj();  //No need of Downcasting to Integer 
System.out.println("r1 : "+r1);
		
Box<Double> b2 = new Box<Double>(); //Here we are already specifying that only Double type objects are allowed
b2.setObj(new Double(11.33)); //No need of downcasting to Double
Double r2 = b2.getObj();
System.out.println("r2 : "+r2);


Box<Integer> b5 = new Box<Integer>(); 
//b5.setObj("123"); // Type checking done at compile time

✅GOAL - Type checking at compile time (Achieved)

-----------------------------------------------------------

(main2) -->

List<Integer> list = new ArrayList<Integer>( ); 
list.add(10); 
list.add(20); 
list.add(30); 
list.add(40); 
//list.add("50"); // type-checking is done at compile time , will give error at compile time  
		
for(Integer ele : list) {
	System.out.println(ele);
}

✅GOAL - Type checking at compile time (Achieved)


## Advantages of Generics -

	1. Stronger type checking at compile time i.e. type-safe coding.
	2. Explicit type casting is not required.
	3. Generic data structure and algorithm implementation.

===========================================================

## (demo06) -- Bounded generic types

// T can be any type so that T is Number or its sub-class.

class Box<T extends Number> {
private T obj;
public T get() {
return this.obj;
}
public void set(T obj) {
this.obj = obj;
}
}

===========================================================

## (demo07) -- Unbounded generic types

(main1) --> unbounded generic type reference

(main2) --> Upperbounded generic type reference

(main3) --> Lowerbounded generic type reference

- These three are used in static methods (we have seen in demo)



===========================================================

## (demo01) -- Exception Handling

## (demo02) -- Generic Exception Handling ----->  catch(Throwable e)  
	Throwable is super class of Error , Exception

## (demo03) -- User defined Exception class


===========================================================

What is difference between throw and throws ?

=> throw --> Manually throw an exception object
   throws --> Declare that method might throw exceptions















